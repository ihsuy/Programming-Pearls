#include <math.h>
#include <algorithm>
#include <bitset>
#include <chrono>
#include <fstream>
#include <iostream>
#include <list>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

typedef long long ll;
template <typename T>
inline void inspect(T& t) {
    typename T::iterator i1 = t.begin(), i2 = t.end();
    while (i1 != i2) {
        std::cout << (*i1) << ' ';
        i1++;
    }
    std::cout << '\n';
}

/////////////////////////////////////////////////////////////
using namespace std;

/*
Can you implement Bob Floyd’s algorithm using the IntSets in this section?
How do these structures perform on the nonrandom distributions
generated by Floyd’s algorithm?
*/

/*
common interface:

class IntSetImp {
public:
    IntSetImp(int maxelements, int maxval);
    void insert(int t);
    int size();
    void report(int *v);
};
*/

class IntSetSTL {
    set<int> S;

   public:
    IntSetSTL(const int& maxelements, const int& maxval) {}
    void insert(const int& t) { S.insert(t); }
    int size() { return S.size(); }
    void report(int* v) {
        int i = 0;
        for (auto& item : S) {
            v[i++] = item;
        }
    }
};

class IntSetArray {
    int* S;
    int sz;

   public:
    IntSetArray(const int& maxelements, const int& maxval) {
        S = new int[maxelements + 1];
        S[0] = maxval;
        sz = 0;
    }
    void insert(const int& t) {
        int i = 0;
        for (; S[i] < t; ++i)
            ;

        if (S[i] == t) {
            return;
        }

        for (int j = sz; j >= i; --j) {
            S[j + 1] = S[j];
        }

        S[i] = t;
        sz++;
    }
    int size() { return sz; }
    void report(int* v) {
        for (int i = 0; i < sz; ++i) {
            v[i] = S[i];
        }
    }
    ~IntSetArray() { delete S; }
};

class IntSetList {
    struct node {
        int val;
        node* next;
        node(const int& val, node* nx) : val(val), next(nx) {}
    };
    int sz;
    node *head, *sentinel;

   public:
    IntSetList(const int& maxelements, const int& maxval) : sz(0) {
        head = new node(maxval, nullptr);
        sentinel = head;
    }
    void insert(const int& num) {
        if (head->next == nullptr or head->val > num) {
            head = new node(num, head);
            sz++;
            return;
        }

        node* temp = head;
        while (temp->next->val < num) {
            temp = temp->next;
        }
        if (temp->next->val == num) {
            return;
        }
        temp->next = new node(num, temp->next);
        sz++;
    }
    int size() { return sz; }
    void report(int* v) {
        int i = 0;
        node* temp = head;
        while (temp != sentinel) {
            v[i++] = temp->val;
            temp = temp->next;
        }
    }

    void DestroyList(node* ptr) {
        if (ptr->next == nullptr) {
            return;
        }
        DestroyList(ptr->next);
        delete ptr;
    }
    ~IntSetList() { DestroyList(head); }
};

class IntSetBST {
    struct node {
        int val;
        node *left, *right;
        node(const int& v, node* l, node* r) : val(v), left(l), right(r) {}
    };
    node* root;
    int sz;

   public:
    IntSetBST(const int& maxelements, const int& maxval)
        : root(nullptr), sz(0) {}
    void insert(const int& num) {
        if (root == nullptr) {
            root = new node(num, nullptr, nullptr);
            sz++;
            return;
        }

        node *temp = root, *savetemp = root;
        while (temp != nullptr) {
            savetemp = temp;
            if (temp->val > num) {
                temp = temp->left;
            } else if (temp->val < num) {
                temp = temp->right;
            } else {
                return;
            }
        }

        if (savetemp->val > num) {
            savetemp->left = new node(num, nullptr, nullptr);
        } else {
            savetemp->right = new node(num, nullptr, nullptr);
        }
        sz++;
    }

    void InOrderTraverse(node* root, int* v, int& i) {
        if (root == nullptr) {
            return;
        }

        InOrderTraverse(root->left, v, i);
        v[i++] = root->val;
        InOrderTraverse(root->right, v, i);
    }

    void report(int* v) {
        int i = 0;
        InOrderTraverse(root, v, i);
    }

    int size() { return sz; }
};

/*
IntSetImp(int maxelements, int maxval);
    void insert(int t);
    int size();
    void report(int *v);
*/

class IntSetBitVec {
    enum { BITSPERWORD = 32, SHIFT = 5, MASK = 0x1f };
    int* bits;
    int sz, capacity;

    void set(const int& i) { bits[i >> SHIFT] |= (1 << (i & MASK)); }

    void clr(const int& i) { bits[i >> SHIFT] &= ~(1 << (i & MASK)); }

    bool test(const int& i) { return bits[i >> SHIFT] & (1 << (i & MASK)); }

   public:
    IntSetBitVec(const int& maxelements, const int& maxval)
        : bits(new int[(maxval >> SHIFT) + 1]), sz(0), capacity(maxval) {
        for (int i = 0; i < capacity; ++i) {
            clr(i);
        }
    }

    int size() { return sz; }

    void insert(const int& num) {
        if (!test(num)) {
            set(num);
            sz++;
        }
    }

    void report(int* v) {
        for (int i = 0, j = 0; i < capacity; ++i) {
            if (test(i)) {
                v[j++] = i;
            }
        }
    }
};

class IntSetBin {
    struct node {
        int val;
        node* next;
        node(const int& v, node* nx) : val(v), next(nx) {}
    };
    node** bins;
    node* sentinel;
    int sz, nbins, max_value;

   public:
    IntSetBin(const int& maxelements, const int& maxval)
        : sentinel(new node(maxval, nullptr)),
          sz(0),
          nbins(maxelements),
          max_value(maxval) {
        bins = new node*[nbins];
        for (int i = 0; i < nbins; ++i) {
            bins[i] = sentinel;
        }
    }

    int size() { return sz; }

    void insert(const int& num) {
        int choice = num / (1 + (max_value / nbins));

        if (bins[choice]->next == nullptr or bins[choice]->val > num) {
            bins[choice] = new node(num, bins[choice]);
            sz++;
            return;
        }

        auto temp = bins[choice];

        while (temp->next->val < num) {
            temp = temp->next;
        }

        if (temp->next->val == num) {
            return;
        }

        temp->next = new node(num, temp->next);
        sz++;
    }

    void report(int* v) {
        for (int i = 0, j = 0; i < nbins; ++i) {
            auto temp = bins[i];
            while (temp->val < max_value) {
                v[j++] = temp->val;
                temp = temp->next;
            }
        }
    }
};

/*
Task:

void gensets(int m, int maxval)
{   int *v = new int[m];
    IntSetImp S(m, maxval);
    while (S.size() < m)
        S.insert(bigrand() % maxval);
    S.report(v);
    for (int i = 0; i < m; i++)
        cout << v[i] << "\n";
}
*/

template <typename IntSet>
void genset(const int& m, const int& n, int* v, IntSet& s) {
    while (s.size() != m) {
        s.insert(rand() % n);
    }
    s.report(v);
}

template <typename IntSet>
void genset_floyd(const int& m, const int& n, int* v, IntSet& s) {
    for (int i = n - m; i < n; ++i) {
        auto select = rand() % (i + 1), sz = s.size();
        s.insert(select);
        if (s.size() == sz) {
            s.insert(i);
        }
    }
    s.report(v);
}

template <typename IntSet>
void profiler(void(gs)(const int&, const int&, int*, IntSet&),
              const int& m,
              const int& n,
              int* v,
              const string& name) {
    IntSet s(m, n);
    auto t1 = chrono::high_resolution_clock::now();
    gs(m, n, v, s);
    auto t2 = chrono::high_resolution_clock::now() - t1;
    auto t = chrono::duration_cast<chrono::microseconds>(t2).count();
    cout << "data structure: " << name << " time spent: " << t
         << " microseconds\n";
}

int main() {
    srand(chrono::high_resolution_clock::now().time_since_epoch().count());

    const int max_n = 1000000;
    const int min_m = 10000;
    const int max_m = 50000;
    for (int m = min_m; m <= max_m; m += min_m) {
        cout << "m: " << m << " n: " << max_n << '\n';
        int v[m];
        // profiler(genset_floyd<IntSetSTL>, m, max_n, v, "IntSetSTL");
        // profiler(genset_floyd<IntSetArray>, m, max_n, v, "IntSetArray");
        // profiler(genset_floyd<IntSetList>, m, max_n, v, "IntSetList");
        // profiler(genset_floyd<IntSetBST>, m, max_n, v, "IntSetBST");
        profiler<IntSetBitVec>(genset<IntSetBitVec>, m, max_n, v,
                               "IntSetBitVec");
        profiler<IntSetBin>(genset<IntSetBin>, m, max_n, v, "IntSetBin");
        profiler<IntSetBitVec>(genset_floyd<IntSetBitVec>, m, max_n, v,
                               "IntSetBitVec");
        profiler<IntSetBin>(genset_floyd<IntSetBin>, m, max_n, v, "IntSetBin");
    }
    return 0;
}
