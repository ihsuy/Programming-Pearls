#include <iostream>
#include <vector>
#include <unordered_set>
#include <unordered_map>
#include <set>
#include <map>
#include <list>
#include <chrono>
#include <random>
#include <algorithm>
#include <math.h>
#include <queue>
#include <stack>
#include <sstream>
#include <utility>
#include <bitset>
#include <fstream>
#include <string>

typedef long long ll;
template<typename T>
inline void inspect(T& t) {typename T::iterator i1 = t.begin(), i2 = t.end(); while (i1 != i2) {std::cout << (*i1) << ' '; i1++;} std::cout << '\n';}

/////////////////////////////////////////////////////////////
using namespace std;

/*
Can you implement Bob Floyd’s algorithm using the IntSets in this section?
How do these structures perform on the nonrandom distributions
generated by Floyd’s algorithm?
*/

/*
common interface:

class IntSetImp {
public:
    IntSetImp(int maxelements, int maxval);
    void insert(int t);
    int size();
    void report(int *v);
};
*/

class IntSetSTL
{
    set<int> S;
public:
    IntSetSTL(const int& maxelements, const int& maxval) {}
    void insert(const int& t)
    {
        S.insert(t);
    }
    int size()
    {
        return S.size();
    }
    void report(int* v)
    {
        int i = 0;
        for (auto& item : S)
        {
            v[i++] = item;
        }
    }
};

class IntSetArray
{
    int* S;
    int sz;
public:
    IntSetArray(const int& maxelements, const int& maxval)
    {
        S = new int[maxelements + 1];
        S[0] = maxval;
        sz = 0;
    }
    void insert(const int& t)
    {
        int i = 0;
        for (; S[i] < t; ++i);

        if (S[i] == t)
        {
            return;
        }

        for (int j = sz; j >= i; --j)
        {
            S[j + 1] = S[j];
        }

        S[i] = t;
        sz++;
    }
    int size()
    {
        return sz;
    }
    void report(int* v)
    {
        for (int i = 0; i < sz; ++i)
        {
            v[i] = S[i];
        }
    }
    ~IntSetArray()
    {
        delete S;
    }
};

class IntSetList
{
    struct node
    {
        int val;
        node* next;
        node(const int& val, node* nx): val(val), next(nx) {}
    };
    int sz;
    node *head, *sentinel;
public:
    IntSetList(const int& maxelements, const int& maxval)
        : sz(0)
    {
        head = new node(maxval, nullptr);
        sentinel = head;

    }
    void insert(const int& num)
    {
        if (head->next == nullptr)
        {
            head = new node(num, head);
            return;
        }

        node* temp = head;
        while (temp->next->val < num)
        {
            temp = temp->next;
        }
        if (temp->next->val == num)
        {
            return;
        }
        temp->next = new node(num, temp->next);
        sz++;
    }
    int size()
    {
        return sz;
    }
    void report(int* v)
    {
        int i = 0;
        node* temp = head;
        while(temp!=sentinel)
        {
            v[i++] = temp->val;
            temp = temp->next;
        }
    }

    void DestroyList(node* ptr)
    {
        if(ptr->next == nullptr)
        {
            return;
        }
        DestroyList(ptr->next);
        delete ptr;
    }
    ~IntSetList()
    {
        DestroyList(head);
    }
};



/*
Task:

void gensets(int m, int maxval)
{   int *v = new int[m];
    IntSetImp S(m, maxval);
    while (S.size() < m)
        S.insert(bigrand() % maxval);
    S.report(v);
    for (int i = 0; i < m; i++)
        cout << v[i] << "\n";
}
*/

template<typename IntSet>
void genset(const int& m, const int& n, int*& v)
{
    IntSet s(m, n);
    while(s.size() != m)
    {
        s.insert(rand()%n);
    }
    
    s.report(v);
}

void profiler(void(gs)(const int&, const int&, int*&),
  const int& m, const int& n, int* v, const string& name)
{
    auto t1 = chrono::high_resolution_clock::now();
    gs(m, n, v);
    auto t2 = chrono::high_resolution_clock::now()-t1;
    auto t = chrono::duration_cast<chrono::microseconds>(t2).count();
    cout << "data structure: " << name << " time spent: " << t << " microseconds\n";
}

int main()
{
    const int& max_n = 1000000;
    for(int m = 10000; m <= 40000; m+=10000)
    {
        cout << "m: " << m << " n: " << max_n << '\n';
        int v[m];
        profiler(genset<IntSetSTL>, m, max_n, v, "IntSetSTL");
        profiler(genset<IntSetArray>, m, max_n, v, "IntSetArray");
        profiler(genset<IntSetList>, m, max_n, v, "IntSetList");
    }

    return 0;
}
