#include <iostream>
#include <vector>
#include <unordered_set>
#include <unordered_map>
#include <set>
#include <map>
#include <list>
#include <chrono>
#include <random>
#include <algorithm>
#include <math.h>
#include <queue>
#include <stack>
#include <sstream>
#include <utility>
#include <bitset>
#include <fstream>
#include <string>

typedef long long ll;
template<typename T>
inline void inspect(T& t) {typename T::iterator i1 = t.begin(), i2 = t.end(); while (i1 != i2) {std::cout << (*i1) << ' '; i1++;} std::cout << '\n';}

/////////////////////////////////////////////////////////////
using namespace std;

/*
Can you implement Bob Floyd’s algorithm using the IntSets in this section?
How do these structures perform on the nonrandom distributions
generated by Floyd’s algorithm?
*/

/*
common interface:

class IntSetImp {
public:
    IntSetImp(int maxelements, int maxval);
    void insert(int t);
    int size();
    void report(int *v);
};
*/

class IntSetSTL
{
    set<int> S;
public:
    IntSetSTL(const int& maxelements, const int& maxval) {}
    void insert(const int& t)
    {
        S.insert(t);
    }
    int size()
    {
        return S.size();
    }
    void report(int* v)
    {
        int i = 0;
        for (auto& item : S)
        {
            v[i++] = item;
        }
    }
};

class IntSetArray
{
    int* S;
    int sz;
public:
    IntSetArray(const int& maxelements, const int& maxval)
    {
        S = new int[maxelements + 1];
        S[0] = maxval;
        sz = 0;
    }
    void insert(const int& t)
    {
        int i = 0;
        for (; S[i] < t; ++i);

        if (S[i] == t)
        {
            return;
        }

        for (int j = sz; j >= i; --j)
        {
            S[j + 1] = S[j];
        }

        S[i] = t;
        sz++;
    }
    int size()
    {
        return sz;
    }
    void report(int* v)
    {
        for (int i = 0; i < sz; ++i)
        {
            v[i] = S[i];
        }
    }
    ~IntSetArray()
    {
        delete S;
    }
};

class IntSetList
{
    struct node
    {
        int val;
        node* next;
        node(const int& val, node* nx): val(val), next(nx) {}
    };
    int sz;
    node *head, *sentinel;
public:
    IntSetList(const int& maxelements, const int& maxval)
        : sz(0)
    {
        head = new node(maxval, nullptr);
        sentinel = head;

    }
    void insert(const int& num)
    {
        if (head->next == nullptr)
        {
            head = new node(num, head);
            sz++;
            return;
        }

        node* temp = head;
        while (temp->next->val < num)
        {
            temp = temp->next;
        }
        if (temp->next->val == num)
        {
            return;
        }
        temp->next = new node(num, temp->next);
        sz++;
    }
    int size()
    {
        return sz;
    }
    void report(int* v)
    {
        int i = 0;
        node* temp = head;
        while (temp != sentinel)
        {
            v[i++] = temp->val;
            temp = temp->next;
        }
    }

    void DestroyList(node* ptr)
    {
        if (ptr->next == nullptr)
        {
            return;
        }
        DestroyList(ptr->next);
        delete ptr;
    }
    ~IntSetList()
    {
        DestroyList(head);
    }
};

class IntSetBST
{
    struct node
    {
        int val;
        node* left, *right;
        node(const int& v, node* l, node* r)
            : val(v), left(l), right(r) {}
    };
    node* root;
    int sz;

public:

    IntSetBST(const int& maxelements, const int& maxval)
        : root(nullptr), sz(0) {}
    void insert(const int& num)
    {
        if (root == nullptr)
        {
            root = new node(num, nullptr, nullptr);
            sz++;
            return;
        }

        node* temp = root, *savetemp = root;
        while (temp != nullptr)
        {
            savetemp = temp;
            if (temp->val > num)
            {
                temp = temp->left;
            }
            else if (temp->val < num)
            {
                temp = temp->right;
            }
            else
            {
                return;
            }
        }

        if (savetemp->val > num)
        {
            savetemp->left = new node(num, nullptr, nullptr);
        }
        else
        {
            savetemp->right = new node(num, nullptr, nullptr);
        }
        sz++;
    }

    void InOrderTraverse(node* root, int* v, int& i)
    {
        if (root == nullptr)
        {
            return;
        }

        InOrderTraverse(root->left, v, i);
        v[i++] = root->val;
        InOrderTraverse(root->right, v, i);
    }

    void report(int* v)
    {
        int i = 0;
        InOrderTraverse(root, v, i);
    }

    int size()
    {
        return sz;
    }
};

/*
IntSetImp(int maxelements, int maxval);
    void insert(int t);
    int size();
    void report(int *v);
*/

class IntSetBitVec
{
    enum {BITSPERWORD = 32, SHIFT = 5, MASK = 0x1f};
    int* bits;
    int sz, capacity;

    void set(const int& i)
    {
        bits[i >> SHIFT] |= (1 << (i & MASK));
    }

    void clr(const int& i)
    {
        bits[i >> SHIFT] &= ~(1 << (i & MASK));
    }

    bool test(const int& i)
    {
        return bits[i >> SHIFT] & (1 << (i & MASK));
    }

public:
    IntSetBitVec(const int& maxelements, const int& maxval):
        bits(new int[(maxval >> SHIFT) + 1]), sz(0), capacity(maxval)
    {
        memset(bits, 0, maxelements);
    }

    int size()
    {
        return sz;
    }

    void insert(const int& num)
    {
        if (!test(num))
        {
            set(num);
            sz++;
        }
    }

    void report(int* v)
    {
        for (int i = 0, j = 0; i < capacity; ++i)
        {
            if (test(i))
            {
                v[j++] = i;
            }
        }
    }
};

class IntSetBin
{
    struct node
    {
        int val;
        node* next;
        node(const int& v, node* nx): val(v), next(nx) {}
    };
    node** bins;
    node* sentinel;
    int sz, nbins, max_value;

public:

    IntSetBin(const int& maxelements, const int& maxval)
        : sentinel(new node(maxval, nullptr)),
          sz(0), nbins(maxelements), max_value(maxval)
    {
        bins = new node*[nbins];
        for (int i = 0; i < nbins; ++i)
        {
            bins[i] = sentinel;
        }
    }

    int size ()
    {
        return sz;
    }

    void insert(const int& num)
    {
        int choice = num / (1 + (max_value / nbins));

        if (bins[choice]->next == nullptr)
        {
            bins[choice] = new node(num, bins[choice]);
            sz++;
            return;
        }

        auto temp = bins[choice];

        while (temp->next->val < num)
        {
            temp = temp->next;
        }

        if (temp->next->val == num)
        {
            return;
        }

        temp->next = new node(num, temp->next);
        sz++;
    }

    void report(int* v)
    {
        for (int i = 0, j = 0; i < nbins; ++i)
        {
            auto temp = bins[i];
            while(temp->val < max_value)
            {
                v[j++] = temp->val;
                temp = temp->next;
            }
        }
    }
};

/*
Task:

void gensets(int m, int maxval)
{   int *v = new int[m];
    IntSetImp S(m, maxval);
    while (S.size() < m)
        S.insert(bigrand() % maxval);
    S.report(v);
    for (int i = 0; i < m; i++)
        cout << v[i] << "\n";
}
*/

template<typename IntSet>
void genset(const int& m, const int& n, int*& v)
{
    IntSet s(m, n);
    while (s.size() != m)
    {
        s.insert(rand() % n);
    }

    s.report(v);
}

void profiler(void(gs)(const int&, const int&, int*&),
              const int& m, const int& n, int* v, const string& name)
{
    auto t1 = chrono::high_resolution_clock::now();
    gs(m, n, v);
    auto t2 = chrono::high_resolution_clock::now() - t1;
    auto t = chrono::duration_cast<chrono::microseconds>(t2).count();
    cout << "data structure: " << name << " time spent: " << t << " microseconds\n";
}

/*
Results on small m, n
m: 10000 n: 100000
data structure: IntSetSTL time spent: 8116 microseconds
data structure: IntSetArray time spent: 92561 microseconds
data structure: IntSetList time spent: 87416 microseconds
data structure: IntSetBST time spent: 1825 microseconds
data structure: IntSetBitVec time spent: 548 microseconds
data structure: IntSetBin time spent: 968 microseconds
m: 20000 n: 100000
data structure: IntSetSTL time spent: 14807 microseconds
data structure: IntSetArray time spent: 343468 microseconds
data structure: IntSetList time spent: 549007 microseconds
data structure: IntSetBST time spent: 6442 microseconds
data structure: IntSetBitVec time spent: 1025 microseconds
data structure: IntSetBin time spent: 2455 microseconds
m: 30000 n: 100000
data structure: IntSetSTL time spent: 29777 microseconds
data structure: IntSetArray time spent: 840238 microseconds
data structure: IntSetList time spent: 1628023 microseconds
data structure: IntSetBST time spent: 7310 microseconds
data structure: IntSetBitVec time spent: 1234 microseconds
data structure: IntSetBin time spent: 3101 microseconds
m: 40000 n: 100000
data structure: IntSetSTL time spent: 39728 microseconds
data structure: IntSetArray time spent: 1487178 microseconds
data structure: IntSetList time spent: 3994499 microseconds
data structure: IntSetBST time spent: 10898 microseconds
data structure: IntSetBitVec time spent: 1547 microseconds
data structure: IntSetBin time spent: 4481 microseconds
m: 50000 n: 100000
data structure: IntSetSTL time spent: 42727 microseconds
data structure: IntSetArray time spent: 2400196 microseconds
data structure: IntSetList time spent: 7655271 microseconds
data structure: IntSetBST time spent: 15512 microseconds
data structure: IntSetBitVec time spent: 1905 microseconds
data structure: IntSetBin time spent: 6673 microseconds
*/
int main()
{
    srand(chrono::high_resolution_clock::now().time_since_epoch().count());

    const int max_n = 100000;
    const int min_m = 10000;
    const int max_m = 50000;
    for (int m = min_m; m <= max_m; m += min_m)
    {
        cout << "m: " << m << " n: " << max_n << '\n';
        int v[m];
        profiler(genset<IntSetSTL>, m, max_n, v, "IntSetSTL");
        profiler(genset<IntSetArray>, m, max_n, v, "IntSetArray");
        profiler(genset<IntSetList>, m, max_n, v, "IntSetList");
        profiler(genset<IntSetBST>, m, max_n, v, "IntSetBST");
        profiler(genset<IntSetBitVec>, m, max_n, v, "IntSetBitVec");
        profiler(genset<IntSetBin>, m, max_n, v, "IntSetBin");
    }
    return 0;
}
